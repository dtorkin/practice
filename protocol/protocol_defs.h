/*
 * protocol/protocol_defs.h
 *
 * Описание:
 * Содержит все определения данных, специфичные для протокола взаимодействия
 * СВ-М и УВМ: константы, перечисления, структуры сообщений (заголовок, тело),
 * и определения комплексных типов.
 * Заменяет часть оригинального common.h.
 */

#ifndef PROTOCOL_DEFS_H
#define PROTOCOL_DEFS_H

#include <stdint.h>
#include <stddef.h> // Для size_t

// --- Константы ---
#define MAX_MESSAGE_BODY_SIZE 65522 // Максимальный размер тела сообщения (из раздела 4.1)
#define LOGICAL_ADDRESS_UVM			  0x01 // Логический адрес УВМ (из таблицы 4.2)
#define LOGICAL_ADDRESS_SVM_PB_BZ_CHANNEL_1 0x08 // Пример логического адреса СВ-М (из таблицы 4.2)
// ... (можно добавить остальные адреса из Таблицы 4.2 при необходимости)

// --- Перечисления ---

// Режимы работы РСА
typedef enum {
	MODE_OR  = 0,     // Режим OP (значение из таблицы 4.22)
	MODE_OR1 = 128,   // Режим OP1 (значение из таблицы 4.22)
	MODE_DR,          // Режим ДР (явно не указано числовое значение в табл. 4.22, предполагаем следующее)
	MODE_VR  = 2      // Режим ВР (значение из таблицы 4.22)
} RadarMode;

// Состояние SVM (SVM State)
typedef enum {
	STATE_NOT_INITIALIZED, // Не инициализировано
	STATE_INITIALIZED,	 // Инициализировано
	STATE_SELF_TEST		 // Самоконтроль
} SVMState;

// [Таблица 4.2] Логические адреса (Пример)
typedef enum {
	LOGICAL_ADDRESS_UVM_VAL = LOGICAL_ADDRESS_UVM,
	LOGICAL_ADDRESS_SVM_PB_BZ_CHANNEL_1_VAL = LOGICAL_ADDRESS_SVM_PB_BZ_CHANNEL_1,
    // ... Добавить остальные адреса при необходимости
} LogicalAddress;

// [Таблица 4.4] Типы сообщений
typedef enum {
	// --- От УВМ к СВ-М ---
	MESSAGE_TYPE_INIT_CHANNEL = 128, // 4.2.1. «Инициализация канала»
	MESSAGE_TYPE_PROVESTI_KONTROL = 1, // 4.2.3. «Провести контроль»
	MESSAGE_TYPE_VYDAT_RESULTATY_KONTROLYA = 2, // 4.2.5. «Выдать результаты контроля»
	MESSAGE_TYPE_VYDAT_SOSTOYANIE_LINII = 6, // 4.2.7. «Выдать состояние линии»
	MESSAGE_TYPE_PRIYAT_PARAMETRY_SO = 160, // 4.2.9. «Принять параметры СО»
	MESSAGE_TYPE_PRIYAT_TIME_REF_RANGE = 161, // 4.2.10. «Принять TIME_REF_RANGE»
	MESSAGE_TYPE_PRIYAT_REPER = 162,		  // 4.2.11. «Принять Reper»
	MESSAGE_TYPE_PRIYAT_PARAMETRY_SDR = 170, // 4.2.12. «Принять параметры СДР»
	MESSAGE_TYPE_PRIYAT_PARAMETRY_3TSO = 200, // 4.2.13. «Принять параметры 3ЦО»
	MESSAGE_TYPE_PRIYAT_REF_AZIMUTH = 201,	// 4.2.14. «Принять REF_AZIMUTH»
	MESSAGE_TYPE_PRIYAT_PARAMETRY_TSD = 210, // 4.2.15. «Принять параметры ЦДР»
	MESSAGE_TYPE_NAVIGATSIONNYE_DANNYE = 255,  // 4.2.16. «Навигационные данные»

	// --- От СВ-М к УВМ ---
	MESSAGE_TYPE_CONFIRM_INIT = 129, // 4.2.2. «Подтверждение инициализации канала»
	MESSAGE_TYPE_PODTVERZHDENIE_KONTROLYA = 3, // 4.2.4. «Подтверждение контроля»
	MESSAGE_TYPE_RESULTATY_KONTROLYA = 4, // 4.2.6. «Результаты контроля»
	MESSAGE_TYPE_SOSTOYANIE_LINII = 7, // 4.2.8. «Состояние линии»
	MESSAGE_TYPE_SUBK = 127,                 // 4.2.17. «СУБК»
    MESSAGE_TYPE_KO = 137,                   // 4.2.18. «КО»
    MESSAGE_TYPE_STROKA_GOLOGRAMMY_SUBK = 8, // 4.2.19. «Строка голограммы СУБК»
    MESSAGE_TYPE_STROKA_RADIOGOLOGRAMMY_DR = 18, // 4.2.20. «Строка радиоголограммы ДР»
    MESSAGE_TYPE_STROKA_K3 = 19,             // 4.2.21. «Строка К3»
    MESSAGE_TYPE_STROKA_IZOBRAZHENIYA_K4 = 20, // 4.2.22. «Строка изображения К4»
    MESSAGE_TYPE_NK = 80,                    // 4.2.23. «НК»
    MESSAGE_TYPE_POMEHA = 81,                // 4.2.24. «Помеха»
    MESSAGE_TYPE_RESULTAT_OP1 = 82,          // 4.2.25. «Результат ОР1»
    MESSAGE_TYPE_RO = 84,                    // 4.2.26. «РО»
    MESSAGE_TYPE_NKDR = 90,                  // 4.2.27. «НКДР»
    MESSAGE_TYPE_PREDUPREZHDENIE = 254       // 4.2.28. «Предупреждение» (Таблица 4.4), 5.2
} MessageType;


// --- Структуры ---

// Определения для комплексных чисел
typedef struct {
	int8_t imag; // Мнимая часть (младший байт)
	int8_t real; // Действительная часть (старший байт)
} complex_int8_t;

typedef struct {
	int16_t imag; // Мнимая часть (младшие 2 байта)
	int16_t real; // Действительная часть (старшие 2 байта)
} complex_fixed16_t; // Используется в PrinyatRefAzimuthBody (но там int16_t по факту)

// [Таблица 4.3] Флаги
typedef struct {
	uint8_t np: 1;	   // Направление передачи (0 - от УВМ к СВ-М, 1 - от СВ-М к УВМ)
	uint8_t hc_t_bp: 1;  // Восьмой разряд номера сообщения
	uint8_t hc_ct_bp: 1; // Девятый разряд номера сообщения
	uint8_t hc_ct10p: 1; // Десятый разряд номера сообщения (Старший разряд номера)
	uint8_t reserve4: 1; // Резерв
	uint8_t reserve5: 1; // Резерв
	uint8_t reserve6: 1; // Резерв
	uint8_t reserve7: 1; // Резерв
} MessageFlags;

// [Таблица 4.1] Заголовок сообщения
typedef struct {
	uint8_t address;		 // Адрес (1 байт) - Кому предназначено сообщение
	MessageFlags flags;	  // Флаги (1 байт)
	uint16_t body_length;	// Длина тела сообщения в байтах (2 байта)
	uint8_t message_number;  // Номер сообщения (1 байт, младшие 8 бит номера: 0-7)
	uint8_t message_type;	// Тип сообщения (1 байт)
} MessageHeader;

// [Таблица 4.1] Общая структура сообщения
typedef struct {
	MessageHeader header;
	uint8_t body[MAX_MESSAGE_BODY_SIZE]; // Тело сообщения (максимальный размер)
} Message;


// --- Структуры тел сообщений ---

// [4.2.1] «Инициализация канала» (тело сообщения) - Таблица 4.5
typedef struct {
	uint8_t lauvm; // Логический адрес УВМ
	uint8_t lak;   // Устанавливаемый логический адрес СВ-М
} InitChannelBody;

// [4.2.2] «Подтверждение инициализации канала» (тело сообщения) - Таблица 4.7
typedef struct {
	uint8_t lak;   // Возвращённый логический адрес СВ-М
	uint8_t slp;   // Состояние линий передач СВ-М (СЛП - битовая маска)
	uint8_t vdr;   // Версия прошивки ПЛИС модуля МОДР (ВДР)
	uint8_t bop1;  // Версия прошивки ПЛИС модуля МОСВ1 (BOP1)
	uint8_t bop2;  // Версия прошивки ПЛИС модуля МОСВ2 (BOP2)
	uint32_t bcb;  // Состояние счётчика времени работы СВ-М (ВСВ)
} ConfirmInitBody;

// [4.2.3] «Провести контроль» (тело сообщения) - Таблица 4.9
typedef struct {
	uint8_t tk; // Тип контроля (ТК - битовая маска)
} ProvestiKontrolBody;

// [4.2.4] «Подтверждение контроля» (тело сообщения) - Таблица 4.11
typedef struct {
	uint8_t lak;  // Логический адрес СВ-М (ЛАК)
	uint8_t tk;   // Тип контроля (ТК) - из запроса
	uint32_t bcb; // Состояние ВСВ (BCB)
} PodtverzhdenieKontrolyaBody;

// [4.2.5] «Выдать результаты контроля» (тело сообщения) - Таблица 4.13
typedef struct {
	uint8_t vrk; // Вид запроса выдачи результатов контроля (ВРК - битовая маска)
} VydatRezultatyKontrolyaBody;

// [4.2.6] «Результаты контроля» (тело сообщения) - Таблица 4.15
typedef struct {
	uint8_t lak;   // Логический адрес СВ-М (ЛАК)
	uint8_t rsk;	 // Результаты контроля СВ-М (РСК - битовая маска)
	uint16_t vsk;	// Время прохождения самоконтроля (ВСК - в мс)
	uint32_t bcb;	// Состояние ВСВ (BCB)
} RezultatyKontrolyaBody;

// [4.2.7] «Выдать состояние линии» (тело сообщения) - Таблица 4.17
// Тело пустое

// [4.2.8] «Состояние линии» (тело сообщения) - Таблица 4.19
typedef struct {
	uint8_t lak;	// Логический адрес СВ-М (ЛАК)
	uint16_t kla;   // Количество изменений состояния LinkUp (1->0) (КЛА)
	uint32_t sla;   // Интегральное время низкого уровня LinkUp (СЛА - в 1/100 мкс)
	uint16_t ksa;   // Количество изменений состояния SignDet (1->0) (КСА)
	uint32_t bcb;   // Состояние ВСВ (BCB)
} SostoyanieLiniiBody;

// [4.2.9] «Принять параметры СО» (тело сообщения) - Таблица 4.21
typedef struct {
    uint8_t pp;         // Режим работы РСА (PP)
    uint8_t brl;        // Маска бланкирования рабочих лучей (БРЛ)
    uint8_t q0;         // Пороговая константа обнаружения активной помехи (Qo)
    uint16_t q;         // Нормализованная константа для сигмы шума (Q)
    uint16_t knk;       // Нормализованная константа порога обнаружения ОР (KNK)
    uint16_t knk_or1;   // Нормализованная константа порога обнаружения ОР1 (KNK_OR1)
    uint8_t weight[23]; // Массив коэффициентов взвешивающего фильтра (Weight) - представлен как fixed8 в док.
    uint16_t l1;        // Длина опоры свёртки по дальности для СУБК первого луча (L1)
    uint16_t l2;        // Длина опоры свёртки по дальности для СУБК второго луча (L2)
    uint16_t l3;        // Длина опоры свёртки по дальности для СУБК третьего луча (L3)
    uint8_t aru;        // Режим работы АРУ устройства МПУ 11B521-4 (ARU) (бит)
    uint8_t karu;       // Константа значения кода аттенюации МПУ (KARU)
    uint16_t sigmaybm;  // Константа номин. среднеквадр. уровня шума на выходе МПУ (SIGMAYBM)
    uint16_t rgd;       // Длина строки радиоголограммы в байтах (РГД)
    uint8_t yo;         // Уровень обработки (УО)
    uint8_t a2;         // Коэффициент допустимого порога (A2)
    uint16_t fixp;      // Уровень фиксированного порога (FixP)
} PrinyatParametrySoBody; // Итого: 1+1+1+2+2+2+23+2+2+2+1+1+2+2+1+1+2 = 54 байта

// [4.2.10] «Принять TIME_REF_RANGE» (тело сообщения) - Таблица 4.23
#define TIME_REF_RANGE_ELEMENTS 400
typedef struct {
	complex_int8_t time_ref_range[TIME_REF_RANGE_ELEMENTS]; // Массив опоры по дальности (400 * 2 = 800 байт)
} PrinyatTimeRefRangeBody;

// [4.2.11] «Принять Reper» (тело сообщения) - Таблица 4.25
typedef struct {
	uint16_t NTSO1;	// Номер цикла обзора для реперной точки 1
	uint16_t ReperR1;  // Координаты по дальности реперной точки 1
	uint16_t ReperA1;  // Координаты по азимуту реперной точки 1
	uint16_t NTSO2;	// Номер цикла обзора для реперной точки 2
	uint16_t ReperR2;  // Координаты по дальности реперной точки 2
	uint16_t ReperA2;  // Координаты по азимуту реперной точки 2
	uint16_t NTSO3;	// Номер цикла обзора для реперной точки 3
	uint16_t ReperR3;  // Координаты по дальности реперной точки 3
	uint16_t ReperA3;  // Координаты по азимуту реперной точки 3
	uint16_t NTSO4;	// Номер цикла обзора для реперной точки 4
	uint16_t ReperR4;  // Координаты по дальности реперной точки 4
	uint16_t ReperA4;  // Координаты по азимуту реперной точки 4
} PrinyatReperBody; // Итого: 12 * 2 = 24 байта

// [4.2.12] «Принять параметры СДР» (тело сообщения) - Таблица 4.27
// Замечание: HRR[MRR] - массив переменной длины, его нельзя просто так включить в структуру.
// Размер тела будет 45 + MRR * sizeof(complex fixed8) байт.
// Вместо этого определим структуру без HRR, а HRR будем читать отдельно.
// Либо, если MRR фиксирован или имеет разумный максимум, можно заложить буфер.
// Макс. размер сообщения 65512, значит MRR*8 может быть до ~65467, MRR ~ 8183.
// Пусть пока будет структура без HRR. Размер тела = 45.
#define MAX_SDR_HRR_ELEMENTS 8183 // Оценочный максимум для HRR
typedef struct {
    uint8_t pp_nl;      // Режим работы РСА и номер луча (РР и НЛ)
    uint8_t brl;        // Маска бланкирования рабочих лучей (БРЛ)
    uint8_t kdec;       // Коэффициент прореживания (KDEC)
    uint8_t yo;         // Уровень обработки (УО)
    uint8_t sland;      // Доля площади ячейки, занимаемая сушей (SLand) - ufixed8
    uint8_t sf;         // Доля площади ячейки, занимаемая НК (SF) - ufixed8
    uint8_t t0;         // Коэффициент порогового обнаружения суши (t0)
    uint8_t t1;         // Коэффициент порогового обнаружения НК на море (t1)
    uint8_t q0;         // Пороговая константа обнаружения активной помехи (Qo)
    uint16_t q;         // Нормализованная константа для сигмы шума (Q)
    uint8_t aru;        // Режим работы АРУ устройства МПУ (ARU) (бит)
    uint8_t karu;       // Константа значения кода аттенюации МПУ (KARU)
    uint16_t sigmaybm;  // Константа номин. среднеквадр. уровня шума на выходе МПУ (SIGMAYBM)
    uint8_t kw;         // Код включения взвешивания (KW) (бит)
    uint8_t w[23];      // Массив коэффициентов взвешивающего фильтра W[23] - fixed8
    uint16_t nfft;      // Количество отсчётов БПФ (NFFT)
    uint8_t or_param;   // Размер ячейки порогового обнаружителя по дальности (OR)
    uint8_t oa;         // Размер ячейки порогового обнаружителя по азимуту (ОА)
    uint16_t mrr;       // Количество отсчетов в опоре по дальности (MRR)
    // complex_fixed16_t hrr[mrr]; // Массив опоры по дальности HRR[MRR] - не включаем в структуру
} PrinyatParametrySdrBodyBase; // Итого (без HRR): 1+1+1+1+1+1+1+1+1+2+1+1+2+1+23+2+1+1+2 = 45 байт

// [4.2.13] «Принять параметры 3ЦО» (тело сообщения) - Таблица 4.31
typedef struct {
	uint16_t Rezerv;			// Резерв (2 байта)
	uint16_t Ncadr;			 // Количество строк дальности в СУБК (2 байта)
	uint8_t  Xnum;			  // Количество строк дальности в СУБК для OP1 (1 байт)
	uint8_t  DNA[8][16];		// Диаграмма направленности антенны для OP (128 байт)
	uint8_t  DNA_INVERS[8][16]; // Инверсная диаграмма для OP (128 байт)
	uint8_t  DNA_OR1[16];	   // Диаграмма направленности для OP1 (16 байт)
	uint8_t  DNA_INVERS_OR1[16];// Инверсная диаграмма для OP1 (16 байт)
	uint16_t Q1;				// Нормализованная константа в OP (2 байта)
	uint16_t Q1_OR1;			// Нормализованная константа в OP1 (2 байта)
	uint8_t  Part;			  // Доля суши для СУБК в OP (1 байт) - uint8
	uint8_t  Sea_or_land[16];   // Массив береговой линии для СУБК в OP (16 байт)
} PrinyatParametry3TsoBody; // Итого: 2+2+1+128+128+16+16+2+2+1+16 = 314 байт

// [4.2.14] «Принять REF_AZIMUTH» (тело сообщения) - Таблица 4.33
// Используем define т.к. размер фиксирован
#define REF_AZIMUTH_SIZE (512 * 16 * 2) // = 16384 элементов fixed16 (т.е. 32768 байт)
typedef struct {
	uint16_t NTSO;							 // Номер цикла обзора, с которого действуют параметры
	int16_t  ref_azimuth[REF_AZIMUTH_SIZE]; // Массив азимутальных опор (32768 байт) - fixed16
} PrinyatRefAzimuthBody; // Итого: 2 + 32768 = 32770 байт

// [4.2.15] «Принять параметры ЦДР» (тело сообщения) - Таблица 4.35
// Структура без массивов переменной длины OKM, HShMR, HAR
// Размер тела будет 8 + Nout*sizeof(int8) + Nin*sizeof(uint8) + NAR*Nin*sizeof(complex fixed16)
typedef struct {
    uint16_t rezerv;    // Резерв
    uint16_t nin;       // Количество строк дальности (Nin)
    uint16_t nout;      // Количество строк амплитудного изображения (Nout)
    uint16_t mrn;       // Количество отсчётов в непрореженной строке дальности (MRn)
    uint8_t shmr;       // Максимальный модуль сдвигов отсчётов строк по дальности (ShMR)
    uint8_t nar;        // Количество строк матрицы опор по азимуту (NAR)
    // Массивы OKM[Nout], HShMR[Nin], HAR[NAR, Nin] не включены
} PrinyatParametryTsdBodyBase; // Итого (без массивов): 2+2+2+2+1+1 = 10 байт

// [4.2.16] «Навигационные данные» (тело сообщения) - Таблица 4.37
#define NAV_DATA_SIZE 256
typedef struct {
	uint8_t mnd[NAV_DATA_SIZE]; // Массив навигационных данных (МНД)
} NavigatsionnyeDannyeBody; // Итого: 256 байт

// ... Другие структуры тел сообщений (СУБК, КО, СтрокаГолограммы и т.д.) должны быть добавлены здесь ...
// [5.2] Сообщение "Предупреждение" (Таблица 5.1)
typedef struct {
    uint8_t lak;        // Логический адрес СВ-М
    uint8_t tks;        // Тип критического события (из Таблицы В.1)
    uint8_t pks[6];     // Параметры критического события (48 бит)
    uint32_t bcb;       // Состояние ВСВ
} PreduprezhdenieBody; // Итого: 1+1+6+4 = 12 байт

#endif // PROTOCOL_DEFS_H